# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EH4NkWSfi2H_fzRm1IKVQaPh4a4un7PA
"""

import random
import csv
import numpy as np
import math

def findNPerCoordinates(x, y, Vmax, Hmax):
    if y >= Vmax or y < 0:
        return None
    if x >= Hmax or x < 0:
        return None
    N = x*Vmax + y
    return N

def nodeOutOfCuadrangularLimit_byN(N, centerN, toSideSize, maxH, maxV):
    x, y = findCoordinatesPerN(centerN, maxV)
    minX = x - toSideSize
    maxX = x + toSideSize
    minY = y - toSideSize
    maxY = y + toSideSize
    
    if minX < 0:
        minX = 0
    if maxX >= maxH:
        maxX = maxH - 1
    if minY < 0:
        minY = 0
    if maxY >= maxV:
        maxY = maxV - 1
    
    nxy = findCoordinatesPerN(N, maxV)
    if(nxy[0] > maxX):
        return True
    if(nxy[0] < minX):
        return True
    if(nxy[1] > maxY):
        return True
    if(nxy[1] < minY):
        return True
    
    return False


def findCoordinatesPerN(N, maxV):
    y = N%maxV
    x = (N-y)/maxV
    return int(x), int(y)

def euclidianDistanceFromNodeToNode(i, j, maxV): #j e i son los nombres, indices de los nodos en cuestion
    pair1 = findCoordinatesPerN(i, maxV)
    pair2 = findCoordinatesPerN(j, maxV)
    dx = pair1[0] - pair2[0]
    dy = pair1[1] - pair2[1]
    d = math.sqrt(dx**2 + dy**2)
    return d

def generateRectangularGraph(d=None, v=None, h=None, eDensity=0.5):
    dist_points = random.randrange(50, 100)
    if d is not None:
        dist_points = d
    vertical = random.randrange(10, 140)
    if v is not None:
        vertical = v
    horizontal = int(3500/vertical)
    if h is not None:
        horizontal = h
    
    qnodes = vertical * horizontal
    
    nOfE = int((qnodes-dist_points)*0.5)
    nOfN = qnodes - dist_points - nOfE
    
    point_list = ["d"]*dist_points + ["e"]*(nOfE) + ["n"]*(nOfN)
    random.shuffle(point_list)
    n = 0
    
    for x in range(horizontal):
        for y in range(vertical):
            point_list[n] = str(n) + "." + str(x) + "." + str(y) + "." + point_list[n]
            n+=1
    
    adj_list = list()
    for elem in point_list:
        aux = elem.split(".")
        x = int(aux[1])
        y = int(aux[2])
        p_up = findNPerCoordinates(x, y-1, vertical, horizontal)
        p_down = findNPerCoordinates(x, y+1, vertical, horizontal)
        p_left = findNPerCoordinates(x-1, y, vertical, horizontal)
        p_right = findNPerCoordinates(x+1, y, vertical, horizontal)
        innerlist = list()
        if p_up is not None:
            innerlist.append((p_up, random.randrange(1, 10)))
        if p_down is not None:
            innerlist.append((p_down, random.randrange(1, 10)))
        if p_left is not None:
            innerlist.append((p_left, random.randrange(1, 10)))
        if p_right is not None:
            innerlist.append((p_right, random.randrange(1, 10)))
        adj_list.append(innerlist)
        
    return point_list, adj_list, horizontal, vertical

def AlgoritmoDeOmar(G,RectangularGraph,inicio = 0):
    resultado = []

    dist = {}
    for cep in RectangularGraph:
        dist[cep.codigo] = math.inf
    padres = {}
    for cep in RectangularGraph:
        padres[cep.codigo] = ''
    visitados = {}
    for cep in RectangularGraph:
        visitados[cep.codigo] = False
    q = []
    hq.heappush(q, (0,RectangularGraph[inicio].codigo))
    while len(q) > 0:
        _,u = hq.heappop(q)
        if not visitados[u]:
            visitados[u] = True
            for w,v in G[u]:
                if not visitados[v] and w < dist[v]:
                    dist[v] = w
                    padres[v] = u
                    resultado.append((u,v))
                    hq.heappush(q, (w,v))
    return padres,dist,resultado

